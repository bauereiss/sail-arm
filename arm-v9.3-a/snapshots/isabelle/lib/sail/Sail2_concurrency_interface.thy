chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_concurrency_interface.lem\<close>.\<close>

theory "Sail2_concurrency_interface" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail2_values"
  "Sail2_string"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_string\<close>\<close>

datatype( 'a, 'b) result =   Ok " ('a)" | Err " ('b)"



datatype Access_variety =   AV_plain | AV_exclusive | AV_atomic_rmw



datatype Access_strength =   AS_normal | AS_rel_or_acq | AS_acq_rcpc



record Explicit_access_kind  =
  
 Explicit_access_kind_variety ::" Access_variety " 
 Explicit_access_kind_strength ::" Access_strength "  



datatype 'arch_ak Access_kind =   AK_explicit " (Explicit_access_kind)" | AK_ifetch " (unit)" | AK_ttw " (unit)" | AK_arch " 'arch_ak "



record( 'pa, 'ts, 'arch_ak) Mem_read_request =
  
 Mem_read_request_access_kind ::" ( 'arch_ak Access_kind)" 

     Mem_read_request_va ::"  ( bitU list)option " 

     Mem_read_request_pa ::" 'pa " 

     Mem_read_request_translation ::" 'ts " 

     Mem_read_request_size ::" int " 

     Mem_read_request_tag ::" bool "  



record( 'pa, 'ts, 'arch_ak) Mem_write_request =
  
 Mem_write_request_access_kind ::" ( 'arch_ak Access_kind)" 

     Mem_write_request_va ::"  ( bitU list)option " 

     Mem_write_request_pa ::" 'pa " 

     Mem_write_request_translation ::" 'ts " 

     Mem_write_request_size ::" int " 

     Mem_write_request_value ::"  ( bitU list)option " 

     Mem_write_request_tag ::"  bool option "  


record 'pa Mem_write_announce_address =
  
 Mem_write_announce_address_pa ::" 'pa " 

     Mem_write_announce_address_size ::" int "  



datatype( 'abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad =
    Done " 'a "
  | Fail " string "
  | Exception " 'e "
  | Choose " string " " ('regval \<Rightarrow> ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad)"
  | Read_reg " string " " ('regval \<Rightarrow> ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad)"
  | Write_reg " string " " 'regval " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | Mem_read_request " ('pa, 'translation_summary, 'arch_ak) Mem_read_request " " ( (( bitU list *  bool option), 'abort)result \<Rightarrow> ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad)"
  | Mem_write_request " ('pa, 'translation_summary, 'arch_ak) Mem_write_request " " ( (( bool option), 'abort)result \<Rightarrow> ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad)"
  | Mem_write_announce_address " 'pa Mem_write_announce_address " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | Branch_announce_address " ( bitU list) " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | Barrier_request " 'barrier " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | Cache_op_request " 'cache_op " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | TLB_op_request " 'tlb_op " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | Fault_announce " 'fault " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "
  | Eret_announce " 'pa " " ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e) monad "

datatype( 'abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval) event =
    E_choose " string " " 'regval "
  | E_read_reg " string " " 'regval "
  | E_write_reg " string " " 'regval "
  | E_mem_read_request " ('pa, 'translation_summary, 'arch_ak) Mem_read_request " " (( bitU list *  bool option), 'abort) result "
  | E_mem_write_request " ('pa, 'translation_summary, 'arch_ak) Mem_write_request " " (( bool option), 'abort) result "
  | E_mem_write_announce_address " 'pa Mem_write_announce_address "
  | E_branch_announce_address " ( bitU list)"
  | E_barrier_request " 'barrier "
  | E_cache_op_request " 'cache_op "
  | E_tlb_op_request " 'tlb_op "
  | E_fault_announce " 'fault "
  | E_eret_announce " 'pa "

type_synonym( 'abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval) trace =" ( ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval)event)
  list "

\<comment> \<open>\<open>val return : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e.
  'a -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e\<close>\<close>
definition return  :: \<open> 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad \<close>  where 
     \<open> return a = ( Done a )\<close> 
  for  "a"  :: " 'a "


\<comment> \<open>\<open>val bind : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'b 'e.
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e ->
  ('a -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'b 'e) ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'b 'e\<close>\<close>
function (sequential,domintros)  bind  :: \<open>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad \<Rightarrow>('a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad)\<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad \<close>  where 
     \<open> bind (Done a) f = ( f a )\<close> 
  for  "a"  :: " 'a " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Fail msg) f = ( Fail msg )\<close> 
  for  "msg"  :: " string " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Exception e) f = ( Exception e )\<close> 
  for  "e"  :: " 'e " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Choose msg k) f = ( Choose msg ((\<lambda> v .  bind (k v) f)))\<close> 
  for  "k"  :: " 'regval \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "msg"  :: " string " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Read_reg r k) f = ( Read_reg r ((\<lambda> v .  bind (k v) f)))\<close> 
  for  "k"  :: " 'regval \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "r"  :: " string " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Write_reg r v k) f = ( Write_reg r v (bind k f))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "v"  :: " 'regval " 
  and  "r"  :: " string " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Mem_read_request req k) f = ( Mem_read_request req ((\<lambda> v .  bind (k v) f)))\<close> 
  for  "req"  :: "('pa,'translation_summary,'arch_ak)Mem_read_request " 
  and  "k"  :: "(((bitU)list*(bool)option),'abort)result \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Mem_write_request req k) f = ( Mem_write_request req ((\<lambda> v .  bind (k v) f)))\<close> 
  for  "req"  :: "('pa,'translation_summary,'arch_ak)Mem_write_request " 
  and  "k"  :: "(((bool)option),'abort)result \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Mem_write_announce_address a k) f = ( Mem_write_announce_address a (bind k f))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "a"  :: " 'pa Mem_write_announce_address " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Branch_announce_address addr k) f = ( Branch_announce_address addr (bind k f))\<close> 
  for  "addr"  :: "(bitU)list " 
  and  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Barrier_request b k) f = ( Barrier_request b (bind k f))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "b"  :: " 'barrier " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Cache_op_request c k) f = ( Cache_op_request c (bind k f))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "c"  :: " 'cache_op " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (TLB_op_request t k) f = ( TLB_op_request t (bind k f))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "t"  :: " 'tlb_op " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Fault_announce fault k) f = ( Fault_announce fault (bind k f))\<close> 
  for  "fault"  :: " 'fault " 
  and  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad "
|\<open> bind (Eret_announce pa k) f = ( Eret_announce pa (bind k f))\<close> 
  for  "pa"  :: " 'pa " 
  and  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "f"  :: " 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'b,'e)monad " 
by pat_completeness auto


\<comment> \<open>\<open>val throw : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e.
  'e -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e\<close>\<close>
definition throw  :: \<open> 'e \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad \<close>  where 
     \<open> throw e = ( Exception e )\<close> 
  for  "e"  :: " 'e "


\<comment> \<open>\<open>val try_catch : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e1 'e2.
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e1 ->
  ('e1 -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e2) ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e2\<close>\<close>
function (sequential,domintros)  try_catch  :: \<open>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad \<Rightarrow>('e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad)\<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad \<close>  where 
     \<open> try_catch (Done a) h = ( Done a )\<close> 
  for  "a"  :: " 'a " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Fail msg) h = ( Fail msg )\<close> 
  for  "msg"  :: " string " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Exception e) h = ( h e )\<close> 
  for  "e"  :: " 'e1 " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Choose msg k) h = ( Choose msg ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  "k"  :: " 'regval \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "msg"  :: " string " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Read_reg r k) h = ( Read_reg r ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  "k"  :: " 'regval \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "r"  :: " string " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Write_reg r v k) h = ( Write_reg r v (try_catch k h))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "v"  :: " 'regval " 
  and  "r"  :: " string " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Mem_read_request req k) h = ( Mem_read_request req ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  "req"  :: "('pa,'translation_summary,'arch_ak)Mem_read_request " 
  and  "k"  :: "(((bitU)list*(bool)option),'abort)result \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Mem_write_request req k) h = ( Mem_write_request req ((\<lambda> v .  try_catch (k v) h)))\<close> 
  for  "req"  :: "('pa,'translation_summary,'arch_ak)Mem_write_request " 
  and  "k"  :: "(((bool)option),'abort)result \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Mem_write_announce_address a k) h = ( Mem_write_announce_address a (try_catch k h))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "a"  :: " 'pa Mem_write_announce_address " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Branch_announce_address addr k) h = ( Branch_announce_address addr (try_catch k h))\<close> 
  for  "addr"  :: "(bitU)list " 
  and  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Barrier_request b k) h = ( Barrier_request b (try_catch k h))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "b"  :: " 'barrier " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Cache_op_request c k) h = ( Cache_op_request c (try_catch k h))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "c"  :: " 'cache_op " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (TLB_op_request t k) h = ( TLB_op_request t (try_catch k h))\<close> 
  for  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "t"  :: " 'tlb_op " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Fault_announce fault k) h = ( Fault_announce fault (try_catch k h))\<close> 
  for  "fault"  :: " 'fault " 
  and  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad "
|\<open> try_catch (Eret_announce pa k) h = ( Eret_announce pa (try_catch k h))\<close> 
  for  "pa"  :: " 'pa " 
  and  "k"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e1)monad " 
  and  "h"  :: " 'e1 \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e2)monad " 
by pat_completeness auto


\<comment> \<open>\<open> For early return, we abuse exceptions by throwing and catching
   the return value. The exception type is "either 'r 'e", where "Right e"
   represents a proper exception and "Left r" an early return of value "r". \<close>\<close>
type_synonym( 'abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'rv, 'a, 'r, 'e) monadR =" ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'rv, 'a, ( ('r, 'e)sum))
  monad "

\<comment> \<open>\<open> val early_return : forall 'rv 'a 'r 'e. 'r -> monadR 'rv 'a 'r 'e \<close>\<close>
definition early_return  :: \<open> 'a \<Rightarrow>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('a,'b)sum))monad \<close>  where 
     \<open> early_return r = ( throw (Inl r))\<close> 
  for  "r"  :: " 'a "


\<comment> \<open>\<open> val catch_early_return : forall 'rv 'a 'e. monadR 'rv 'a 'a 'e -> monad 'rv 'a 'e \<close>\<close>
definition catch_early_return  :: \<open>('k,'j,'i,'h,'g,'f,'e,'d,'c,'a,(('a,'b)sum))monad \<Rightarrow>('k,'j,'i,'h,'g,'f,'e,'d,'c,'a,'b)monad \<close>  where 
     \<open> catch_early_return m = (
  try_catch m
    ((\<lambda>x .  (case  x of   Inl a => return a | Inr e => throw e ))))\<close> 
  for  "m"  :: "('k,'j,'i,'h,'g,'f,'e,'d,'c,'a,(('a,'b)sum))monad "


\<comment> \<open>\<open>val pure_early_return : forall 'a. either 'a 'a -> 'a\<close>\<close>
definition pure_early_return  :: \<open>('a,'a)sum \<Rightarrow> 'a \<close>  where 
     \<open> pure_early_return = ( (\<lambda>x .  
  (case  x of   Inl a => a | Inr a => a )))\<close>


\<comment> \<open>\<open>val either_bind : forall 'e 'a 'b. either 'e 'a -> ('a -> either 'e 'b) -> either 'e 'b\<close>\<close>
fun either_bind  :: \<open>('e,'a)sum \<Rightarrow>('a \<Rightarrow>('e,'b)sum)\<Rightarrow>('e,'b)sum \<close>  where 
     \<open> either_bind (Inl e) f = ( Inl e )\<close> 
  for  "e"  :: " 'e " 
  and  "f"  :: " 'a \<Rightarrow>('e,'b)sum "
|\<open> either_bind (Inr x) f = ( f x )\<close> 
  for  "x"  :: " 'a " 
  and  "f"  :: " 'a \<Rightarrow>('e,'b)sum "


\<comment> \<open>\<open> Lift to monad with early return by wrapping exceptions \<close>\<close>
\<comment> \<open>\<open> val liftR : forall 'rv 'a 'r 'e. monad 'rv 'a 'e -> monadR 'rv 'a 'r 'e \<close>\<close>
definition liftR  :: \<open>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,'a)monad \<Rightarrow>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('b,'a)sum))monad \<close>  where 
     \<open> liftR m = ( try_catch m ((\<lambda> e .  throw (Inr e))))\<close> 
  for  "m"  :: "('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,'a)monad "


\<comment> \<open>\<open> Catch exceptions in the presence of early returns \<close>\<close>
\<comment> \<open>\<open> val try_catchR : forall 'rv 'a 'r 'e1 'e2. monadR 'rv 'a 'r 'e1 -> ('e1 -> monadR 'rv 'a 'r 'e2) ->  monadR 'rv 'a 'r 'e2 \<close>\<close>
definition try_catchR  :: \<open>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('a,'m)sum))monad \<Rightarrow>('m \<Rightarrow>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('a,'b)sum))monad)\<Rightarrow>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('a,'b)sum))monad \<close>  where 
     \<open> try_catchR m h = (
  try_catch m
    ((\<lambda>x .  (case  x of   Inl r => throw (Inl r) | Inr e => h e ))))\<close> 
  for  "m"  :: "('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('a,'m)sum))monad " 
  and  "h"  :: " 'm \<Rightarrow>('l,'k,'j,'i,'h,'g,'f,'e,'d,'c,(('a,'b)sum))monad "


\<comment> \<open>\<open> val maybe_fail : forall 'rv 'a 'e. string -> maybe 'a -> monad 'rv 'a 'e \<close>\<close>
definition maybe_fail  :: \<open> string \<Rightarrow> 'a option \<Rightarrow>('k,'j,'i,'h,'g,'f,'e,'d,'c,'a,'b)monad \<close>  where 
     \<open> maybe_fail msg = ( (\<lambda>x .  
  (case  x of   Some a => return a | None => Fail msg )))\<close> 
  for  "msg"  :: " string "


\<comment> \<open>\<open>val assert_exp : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  bool -> string -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition assert_exp  :: \<open> bool \<Rightarrow> string \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> assert_exp exp1 msg = ( if exp1 then Done ()  else Fail msg )\<close> 
  for  "exp1"  :: " bool " 
  and  "msg"  :: " string "


\<comment> \<open>\<open>val exit : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e.
  unit -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e\<close>\<close>
definition exit0  :: \<open> unit \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad \<close>  where 
     \<open> exit0 _ = ( Fail (''exit''))\<close>


\<comment> \<open>\<open>val read_reg : forall 's 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e.
  register_ref 's 'regval 'a -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e\<close>\<close>
definition read_reg  :: \<open>('s,'regval,'a)register_ref \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad \<close>  where 
     \<open> read_reg reg = ( 
  (let k = ((\<lambda> v . 
            (case (of_regval   reg) v of
                  Some v => Done v
              | None => Fail (''read_reg: unrecognised value'')
            ))) in Read_reg (name   reg) k) )\<close> 
  for  "reg"  :: "('s,'regval,'a)register_ref "


\<comment> \<open>\<open>val write_reg : forall 's 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e.
  register_ref 's 'regval 'a -> 'a -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition write_reg  :: \<open>('s,'regval,'a)register_ref \<Rightarrow> 'a \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> write_reg reg v = ( Write_reg(name   reg) ((regval_of   reg) v) (Done () ))\<close> 
  for  "reg"  :: "('s,'regval,'a)register_ref " 
  and  "v"  :: " 'a "


\<comment> \<open>\<open>val choose_regval : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'rv 'e.
  string -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'rv 'rv 'e\<close>\<close>
definition choose_regval  :: \<open> string \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'rv,'rv,'e)monad \<close>  where 
     \<open> choose_regval descr = ( Choose descr return )\<close> 
  for  "descr"  :: " string "


\<comment> \<open>\<open>val choose_convert : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'rv 'e 'a.
  ('rv -> maybe 'a) -> string -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'rv 'a 'e\<close>\<close>
definition choose_convert  :: \<open>('rv \<Rightarrow> 'a option)\<Rightarrow> string \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'rv,'a,'e)monad \<close>  where 
     \<open> choose_convert of_rv descr = ( Choose descr ((\<lambda> rv .  maybe_fail descr (of_rv rv))))\<close> 
  for  "of_rv"  :: " 'rv \<Rightarrow> 'a option " 
  and  "descr"  :: " string "


\<comment> \<open>\<open>val choose_convert_default : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'rv 'e 'a.
  ('rv -> maybe 'a) -> 'a -> string -> monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'rv 'a 'e\<close>\<close>
definition choose_convert_default  :: \<open>('rv \<Rightarrow> 'a option)\<Rightarrow> 'a \<Rightarrow> string \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'rv,'a,'e)monad \<close>  where 
     \<open> choose_convert_default of_rv x descr = ( Choose descr ((\<lambda> rv .  return ((case  of_rv rv of
      Some a => a
    | None => x
  )))))\<close> 
  for  "of_rv"  :: " 'rv \<Rightarrow> 'a option " 
  and  "x"  :: " 'a " 
  and  "descr"  :: " string "


definition choose_bool  :: \<open> 'a Register_Value_class \<Rightarrow> string \<Rightarrow>('j,'i,'h,'g,'f,'e,'d,'c,'a,(bool),'b)monad \<close>  where 
     \<open> choose_bool dict_Sail2_values_Register_Value_a descr = ( choose_convert_default 
  (bool_of_regval_method   dict_Sail2_values_Register_Value_a) False descr )\<close> 
  for  "dict_Sail2_values_Register_Value_a"  :: " 'a Register_Value_class " 
  and  "descr"  :: " string "

definition choose_bit  :: \<open> 'b Register_Value_class \<Rightarrow> string \<Rightarrow>('j,'i,'h,'g,'f,'e,'d,'c,'b,(bitU),'a)monad \<close>  where 
     \<open> choose_bit dict_Sail2_values_Register_Value_b descr = ( bind (choose_bool 
  dict_Sail2_values_Register_Value_b descr) ((\<lambda> b .  return (bitU_of_bool b))))\<close> 
  for  "dict_Sail2_values_Register_Value_b"  :: " 'b Register_Value_class " 
  and  "descr"  :: " string "

definition choose_int  :: \<open> 'a Register_Value_class \<Rightarrow> string \<Rightarrow>('j,'i,'h,'g,'f,'e,'d,'c,'a,(int),'b)monad \<close>  where 
     \<open> choose_int dict_Sail2_values_Register_Value_a descr = ( choose_convert_default 
  (int_of_regval_method   dict_Sail2_values_Register_Value_a)(( 0 :: int)) descr )\<close> 
  for  "dict_Sail2_values_Register_Value_a"  :: " 'a Register_Value_class " 
  and  "descr"  :: " string "

definition choose_real  :: \<open> 'a Register_Value_class \<Rightarrow> string \<Rightarrow>('j,'i,'h,'g,'f,'e,'d,'c,'a,(real),'b)monad \<close>  where 
     \<open> choose_real dict_Sail2_values_Register_Value_a descr = ( choose_convert_default 
  (real_of_regval_method   dict_Sail2_values_Register_Value_a)(( 0 :: real)) descr )\<close> 
  for  "dict_Sail2_values_Register_Value_a"  :: " 'a Register_Value_class " 
  and  "descr"  :: " string "

definition choose_string  :: \<open> 'a Register_Value_class \<Rightarrow> string \<Rightarrow>('j,'i,'h,'g,'f,'e,'d,'c,'a,(string),'b)monad \<close>  where 
     \<open> choose_string dict_Sail2_values_Register_Value_a descr = ( choose_convert_default 
  (string_of_regval_method   dict_Sail2_values_Register_Value_a) (''default'') descr )\<close> 
  for  "dict_Sail2_values_Register_Value_a"  :: " 'a Register_Value_class " 
  and  "descr"  :: " string "


definition headM  :: \<open> 'a list \<Rightarrow>('k,'j,'i,'h,'g,'f,'e,'d,'c,'a,'b)monad \<close>  where 
     \<open> headM = ( (\<lambda>x .  
  (case  x of   x # _ => return x | [] => Fail (''headM'') )))\<close>


definition tailM  :: \<open> 'k list \<Rightarrow>('j,'i,'h,'g,'f,'e,'d,'c,'b,('k list),'a)monad \<close>  where 
     \<open> tailM = ( (\<lambda>x .  
  (case  x of   _ # xs => return xs | [] => Fail (''tailM'') )))\<close>


\<comment> \<open>\<open>val sail_mem_read : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'bv 'e. Bitvector 'bv =>
  Mem_read_request 'pa 'translation_summary 'arch_ak ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval (result ('bv * maybe bool) 'abort) 'e\<close>\<close>
definition sail_mem_read  :: \<open> 'bv Bitvector_class \<Rightarrow>('pa,'translation_summary,'arch_ak)Mem_read_request \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,((('bv*(bool)option),'abort)result),'e)monad \<close>  where 
     \<open> sail_mem_read dict_Sail2_values_Bitvector_bv req = (
  (let k = ((\<lambda>x .  (case  x of
                       Ok (res, tag) =>
                 (case (of_bits_method   dict_Sail2_values_Bitvector_bv) res of
                       Some res => return (Ok (res, tag))
                   | None => Fail
                               (''sail_mem_read_request: unrecognised value'')
                 )
                   | Err e => return (Err e)
                 ))) in
  Mem_read_request req k))\<close> 
  for  "dict_Sail2_values_Bitvector_bv"  :: " 'bv Bitvector_class " 
  and  "req"  :: "('pa,'translation_summary,'arch_ak)Mem_read_request "


\<comment> \<open>\<open>val sail_mem_write : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  Mem_write_request 'pa 'translation_summary 'arch_ak ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval (result (maybe bool) 'abort) 'e\<close>\<close>
definition sail_mem_write  :: \<open>('pa,'translation_summary,'arch_ak)Mem_write_request \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,((((bool)option),'abort)result),'e)monad \<close>  where 
     \<open> sail_mem_write req = ( Mem_write_request req return )\<close> 
  for  "req"  :: "('pa,'translation_summary,'arch_ak)Mem_write_request "


\<comment> \<open>\<open>val sail_mem_write_announce_address : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  Mem_write_announce_address 'pa ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_mem_write_announce_address  :: \<open> 'pa Mem_write_announce_address \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_mem_write_announce_address req = ( Mem_write_announce_address req (return () ))\<close> 
  for  "req"  :: " 'pa Mem_write_announce_address "


\<comment> \<open>\<open>val instr_announce : forall 'instr 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'instr ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition instr_announce  :: \<open> 'instr \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> instr_announce pa = ( return ()  )\<close> 
  for  "pa"  :: " 'instr "
 \<comment> \<open>\<open> TODO \<close>\<close>

\<comment> \<open>\<open>val branch_announce : forall 'addr 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e. Bitvector 'addr =>
  integer -> 'addr ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition branch_announce  :: \<open> 'addr Bitvector_class \<Rightarrow> int \<Rightarrow> 'addr \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> branch_announce dict_Sail2_values_Bitvector_addr addr_size addr = ( Branch_announce_address (
  (bits_of_method   dict_Sail2_values_Bitvector_addr) addr) (return () ))\<close> 
  for  "dict_Sail2_values_Bitvector_addr"  :: " 'addr Bitvector_class " 
  and  "addr_size"  :: " int " 
  and  "addr"  :: " 'addr "


\<comment> \<open>\<open>val sail_barrier : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'barrier ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_barrier  :: \<open> 'barrier \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_barrier barrier = ( Barrier_request barrier (return () ))\<close> 
  for  "barrier"  :: " 'barrier "


\<comment> \<open>\<open>val sail_cache_op_request : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'cache_op ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_cache_op_request  :: \<open> 'cache_op \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_cache_op_request cache_op = ( Cache_op_request cache_op (return () ))\<close> 
  for  "cache_op"  :: " 'cache_op "


\<comment> \<open>\<open>val sail_tlbi : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'tlb_op ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_tlbi  :: \<open> 'tlb_op \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_tlbi tlb_op = ( TLB_op_request tlb_op (return () ))\<close> 
  for  "tlb_op"  :: " 'tlb_op "


\<comment> \<open>\<open>val sail_take_exception : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'fault ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_take_exception  :: \<open> 'fault \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_take_exception fault = ( Fault_announce fault (return () ))\<close> 
  for  "fault"  :: " 'fault "


\<comment> \<open>\<open>val sail_return_exception : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'pa ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_return_exception  :: \<open> 'pa \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_return_exception pa = ( Eret_announce pa (return () ))\<close> 
  for  "pa"  :: " 'pa "


\<comment> \<open>\<open>val sail_instr_announce : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'e.
  'pa ->
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval unit 'e\<close>\<close>
definition sail_instr_announce  :: \<open> 'pa \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,(unit),'e)monad \<close>  where 
     \<open> sail_instr_announce pa = ( return ()  )\<close> 
  for  "pa"  :: " 'pa "


\<comment> \<open>\<open> Event traces \<close>\<close>

\<comment> \<open>\<open>val emitEvent : forall 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e.
  Eq 'regval, Eq 'pa, Eq 'barrier, Eq 'cache_op, Eq 'tlb_op, Eq 'fault =>
  monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e
  -> event 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval
  -> maybe (monad 'abort 'barrier 'cache_op 'fault 'pa 'tlb_op 'translation_summary 'arch_ak 'regval 'a 'e)\<close>\<close>
definition emitEvent  :: \<open>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad \<Rightarrow>('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval)event \<Rightarrow>(('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad)option \<close>  where 
     \<open> emitEvent m e = ( (case  (e, m) of
    (E_choose descr v, Choose descr' k) => if descr' = descr then Some (k v) else None
  | (E_read_reg r v, Read_reg r' k) =>
     if r' = r then Some (k v) else None
  | (E_write_reg r v, Write_reg r' v' k) =>
     if (r' = r) \<and> (v' = v) then Some k else None
  | (E_mem_read_request req v, Mem_read_request req' k) =>
     if req' = req then Some (k v) else None
  | (E_mem_write_request req r, Mem_write_request req' k) =>
     if req' = req then Some (k r) else None
  | (E_mem_write_announce_address a, Mem_write_announce_address a' k) =>
     if a' = a then Some k else None
  | (E_branch_announce_address addr, Branch_announce_address addr' k) =>
     if addr' = addr then Some k else None
  | (E_barrier_request r, Barrier_request r' k) =>
     if r' = r then Some k else None
  | (E_cache_op_request r, Cache_op_request r' k) =>
     if r' = r then Some k else None
  | (E_tlb_op_request r, TLB_op_request r' k) =>
     if r' = r then Some k else None
  | (E_fault_announce f, Fault_announce f' k) =>
     if f' = f then Some k else None
  | (E_eret_announce pa, Eret_announce pa' k) =>
     if pa' = pa then Some k else None
  \<comment> \<open>\<open>| (E_barrier bk, Barrier bk' k) ->
     if bk' = bk then Just k else Nothing\<close>\<close>
  | _ => None
))\<close> 
  for  "m"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval,'a,'e)monad " 
  and  "e"  :: "('abort,'barrier,'cache_op,'fault,'pa,'tlb_op,'translation_summary,'arch_ak,'regval)event "


\<comment> \<open>\<open>val runTrace : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> maybe (monad 'regval 'a 'e)\<close>\<close>
fun  runTrace  :: \<open>(('k,'j,'i,'h,'g,'f,'e,'d,'c)event)list \<Rightarrow>('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad \<Rightarrow>(('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad)option \<close>  where 
     \<open> runTrace ([]) m = ( Some m )\<close> 
  for  "m"  :: "('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad "
|\<open> runTrace (e # t') m = ( Option.bind (emitEvent m e) (runTrace t'))\<close> 
  for  "t'"  :: "(('k,'j,'i,'h,'g,'f,'e,'d,'c)event)list " 
  and  "e"  :: "('k,'j,'i,'h,'g,'f,'e,'d,'c)event " 
  and  "m"  :: "('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad "


\<comment> \<open>\<open>val final : forall 'regval 'a 'e. monad 'regval 'a 'e -> bool\<close>\<close>
definition final  :: \<open>('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad \<Rightarrow> bool \<close>  where 
     \<open> final = ( (\<lambda>x .  
  (case  x of
        Done _ => True
    | Fail _ => True
    | Exception _ => True
    | _ => False
  )))\<close>


\<comment> \<open>\<open>val hasTrace : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> bool\<close>\<close>
definition hasTrace  :: \<open>(('a,'b,'c,'d,'e,'f,'g,'h,'i)event)list \<Rightarrow>('a,'b,'c,'d,'e,'f,'g,'h,'i,'j,'k)monad \<Rightarrow> bool \<close>  where 
     \<open> hasTrace t m = ( (case  runTrace t m of
    Some m => final m
  | None => False
))\<close> 
  for  "t"  :: "(('a,'b,'c,'d,'e,'f,'g,'h,'i)event)list " 
  and  "m"  :: "('a,'b,'c,'d,'e,'f,'g,'h,'i,'j,'k)monad "


\<comment> \<open>\<open>val hasException : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> bool\<close>\<close>
definition hasException  :: \<open>(('k,'j,'i,'h,'g,'f,'e,'d,'c)event)list \<Rightarrow>('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad \<Rightarrow> bool \<close>  where 
     \<open> hasException t m = ( (case  runTrace t m of
    Some (Exception _) => True
  | _ => False
))\<close> 
  for  "t"  :: "(('k,'j,'i,'h,'g,'f,'e,'d,'c)event)list " 
  and  "m"  :: "('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad "


\<comment> \<open>\<open>val hasFailure : forall 'regval 'a 'e. Eq 'regval => trace 'regval -> monad 'regval 'a 'e -> bool\<close>\<close>
definition hasFailure  :: \<open>(('k,'j,'i,'h,'g,'f,'e,'d,'c)event)list \<Rightarrow>('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad \<Rightarrow> bool \<close>  where 
     \<open> hasFailure t m = ( (case  runTrace t m of
    Some (Fail _) => True
  | _ => False
))\<close> 
  for  "t"  :: "(('k,'j,'i,'h,'g,'f,'e,'d,'c)event)list " 
  and  "m"  :: "('k,'j,'i,'h,'g,'f,'e,'d,'c,'b,'a)monad "


\<comment> \<open>\<open> Define a type synonym that also takes the register state as a type parameter,
   in order to make switching to the state monad without changing generated
   definitions easier, see also lib/hol/prompt_monad.lem. \<close>\<close>

type_synonym( 'abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'regstate, 'a, 'e) base_monad =" ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'e)
  monad "
type_synonym( 'abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'regstate, 'a, 'r, 'e) base_monadR =" ('abort, 'barrier, 'cache_op, 'fault, 'pa, 'tlb_op, 'translation_summary, 'arch_ak, 'regval, 'a, 'r, 'e)
  monadR "
end
